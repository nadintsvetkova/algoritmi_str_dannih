import copy


def trans(a, n, m):
    b = [0] * m
    for k in range(m):
        b[k] = [k] * n
    for i in range(n):
        for j in range(m):
            b[j][i] = a[i][j]
    return b     


def multi(a, n1, m1, b, n2, m2):
    if m1 != n2:
        return False
    c = [0] * n1
    b = trans(b, n2, m2)
    for k1 in range(n1):
        c[k1] = [0] * m2
    for i in range(n1):
        for j in range(m2):
            for k in range(m1):
                c[i][j] += a[i][k] * b[j][k]
    return c


def rang(a, n, m):
    res = n
    c = copy.deepcopy(a)
    d = copy.deepcopy(a)        
    for i in range(n):
        for j in range(i + 1, n):
            s = d[j]
            d = copy.deepcopy(c)
            print(i, j)
            for k in range(i, m):
                if d[j][i] != 0 and d[i][i] != 0:                                                          
                    c[i][k] = c[i][k] * d[j][i]
                    c[j][k] = d[j][k] * d[i][i]
            b = 0
            if d[j][i] != 0 and d[i][i] != 0:                                                                      
                for k1 in range(m):
                    s[k1] = c[i][k1] - c[j][k1]
                    print("s", s)
                    if s[k1] == 0:
                        b += 1
            else:
                if d[i][i] == 0:
                    for k in range(m):
                        if d[i][k] == 0:
                            b += 1
            c[j] = s
            if b == m:
                res -= 1
    b = 0
    for k in range(m):
        if a[n - 1][k] == 0:
            b += 1
    if b == m:
        res -= 1            
    if res == 0:
        res = 1        
    return res


def opr(a, n):
    res = 0
    if n == 2:
        res = a[0][0] * a[1][1] - a[0][1] * a[1][0]
        return res
    elif n == 1:
        res = a[0][0]
        return res
    elif n == 3:
        for i in range(n):
            k = 1
            for j in range(n):
                k *= a[j][(i + j) % n]
            res += k
            k1 = 1
            for j in range(n):
                k1 *= a[j][(n * n - 1 - i - j) % n]
            res -= k1
        return res
        

def sous(a, n):
    a = trans(a, n, n)
    d = copy.deepcopy(a)
    c = [1] * (n - 1)
    for i in range(n - 1):
        c[i] = [i] * (n - 1)
    for i in range(n):
        for j in range(n):
            for i1 in range(n):
                for j1 in range(n):
                    if i1 < i:
                        if j1 < j:
                            c[i1][j1] = a[i1][j1]
                        if j1 > j:
                            c[i1][j1 - 1] = a[i1][j1]
                    if i1 > i:
                        if j1 < j:
                            c[i1 - 1][j1] = a[i1][j1]
                        if j1 > j:
                            c[i1 - 1][j1 - 1] = a[i1][j1]
            d[i][j] = opr(c, n - 1) * ((-1) ** (i + j))
    return d                



def reverse(a, n):
    b = sous(a, n)
    if opr(a, n) == 0:
        return False
    else:
        k = 1 / opr(a, n)
        for i in range(n):
            for j in range(n):
                b[i][j] *= k
        return b

print("Транспонирование", trans(a, n, m))
print("Умножение", multi(a, n, m, b, 3, 2))
print("Ранг матрицы", rang(a, n, m))
